# pure LISP

## Abstruct

As the name suggests, this program is "pure LISP".

It supports super brackets '[', ']' to group and close brackets together.

## このプログラムについて。

Paul Graham 氏による記事 "The Roots of Lisp" の内容を実行できるものを目指した、純 LISP インタプリタです。

## コンパイル方法

gcc もしくは clang で Makefile を実行してください。

## 使用方法

終了するためのコマンドは実装しておりません。
Ctrl+C でプロセスを終了させてください。

「スーパー括弧」が使えます。これは、丸括弧の代わりに角括弧を使うと何重もの括弧のネストをまとめて閉じることができるものです。
左角括弧は右角括弧のこの機能をその深さで止めるために用いられます。
すなわち、((( ] や ([( ]) は ((( ))) と等しいです。

## イニシャル・ローディング機能

起動すると最初に init.txt を同じディレクトリ内から読み込みます。
ここに、あらかじめ読み込ませておきたい pure LISP プログラムを記述してください。
また、ないときは空の init.txt を作っておいてください。

## 注意事項

シンボルを評価すると、その値に自動的に置換されます。
よって、普通の LISP とは多少挙動の違う部分が表面的にはあります。
新しく用意されたシンボルには自分自身が値として含まれています。
それゆえ、

    % a
    a

となって、違いは表面的には現れませんが（% はプロンプト）、

    % (setq a b)
    a

のようにして値 b をシンボル a に設定すると、

    % a
    b

となります。


## 注意事項その２

ダイナミック・スコープです。

## 注意事項その３

ファイル名を指定しての読込・保存の機能は実装しておりません。

## 実装関数

### 基本７関数

- quote
- car
- cdr
- cons
- cond
- atom
- eq

LISP を齧ったことのある人なら、これらの意味はご存知でしょう。

### lambda

これも LISPer なら知っていて当然でしょう。当処理系においては、これはシンボルです。

### de

    (de func (x_1, ... x_n) S_1, ... S_n)

の形で用い、シンボル func を関数として定義します。
x_1, ... x_n は仮引数で、S_1, ... S_n
は S-式です。
S_1, ... S_n は順次評価され、最後の結果が関数の値として返されます。
内部的には、lamda 式のリストへと変換して、そのリストへのポインタを値としてシンボル func 内に格納します。

### setq

    (setq symbol value)

の形で用います。
シンボルに値を設定します。
当処理系においては、value としてラムダ式のリストを与えると、symbol が関数そのものになります。

### gc

ガベージ・コレクションを起動します。
ダミーとして () を返します。

## 予約シンボル

- ()
    + ヌルを意味します。正しくはシンボルではありません。内部構造もシンボルとは違っていて、名前を格納するセルも、値へのボインタを格納するセルも持ちません。当処理系においては、nil はヌルの意味で使えません（そうするよう、改造は容易）。
- t
    + 真偽値の真を意味します。
- lambda
    + 関数ではありません。先頭にあるとそのリスト全体が無名関数として扱われる、ただの印です。
- oblist
    + oblist を評価すると、すでに定義した関数や、値を設定したシンボルがリストになって表示されます。

## シンボルの構造

シンボル自体もセルから構成されています。すなわち、シンボルも当処理系においては一種のリストなのですが、ユーザからはリストとして扱えないようになっています。

    ((str_1 str_2 ... str_n) (value . next))

が、仮にリストとして表したときのシンボルです。

str_1 ... str_n はそれぞれ4文字までの文字列で、連結されてシンボル名として表示されます。
ただし、文字列バッファとして配列を用いて処理しているので、文字数に限界があります（とりあえずは 100 文字。もちろん変更可能）。
str_n の使用されない部分にはヌル文字が詰め込まれます。

value は関数ポインタ（本物のポインタ）へのポインタ（セル番号）や、リストおよびアトムへのポインタ（セル番号）を格納するためのセルです。

next は、デフォルトでは 0 すなわち () になっています。
けれども、シンボルを連結させて処理する過程において、次のシンボルへのポインタとして使われます。

## 既知の問題点

このコードはほとんどいじることなく PC-9801 のエミュレータにおいて、turbo C でコンバイルできるのですが、そのようにして試しに仮想 PC-9801 上で動かしたところ、一部、狙っていたのと異なる挙動をします。

すなわち、セルの総数を 0x2000 より増やすと、使用メモリは確保されているにも関わらず、明らかにバグります。ところが、エミュレータ上の PC-9801 でなく Mac や Windows 上だと同様のバグは起きません。

ゆえに、おそらくは昔の 8086 cpu におけるメモリ管理上の特殊性が関係していると考え、当時の PC-9801 に関するプログラミングの知識と経験が不足している私は、この問題を放置しています。

しかしながら、メモリ確保が成功しているのにバグる場合があることは、やはり奇妙です。そこに、私のプログラムにファータルなバグが本質的に含まれているかもしれない、という一抹の危惧を感じます。

けれども、何度見直してもそのようなバグは発見できないし、本来の目的である現代の PC 上での動作には、今のところ問題がないので（大していじってませんけども）、やはり放置することにします。

## 言い訳めいたこと

第一に、シンボル名の格納場所をセル領域に含めてしまっています。これは、名前文字列に対して平均で二倍のメモリを消費することになるのですが、シンボル領域とセル領域とに分割管理するのが何か面倒なことのようにプログラミング時の私には思われた。また、純 LISP であることにかこつけて、数値を扱える仕組みを実装しておりません（尤も、改造するのは難しいことではないでしょう。ただ、私としては面倒なだけです）。

第二に、圧倒的にテストが足りていません。
特に、ガベージコレクションに関するテストがです。

第三に、あまり「引き締まった」アルゴリズムやコードではないかもしれません。それはひとえに、いかに楽にプログラミングするかを優先したからですし、私の元々の技量不足もあります。

そもそも、作者としては、ただ単にポール・グレアム氏のエッセイに載っている、いわゆる趙循環評価器の LISP コードを自前の処理系で動かしてみたかっただけなのだから、ご了承ください。
