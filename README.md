# pure LISP

## Abstruct

As the name suggests, this program is "pure LISP".

It supports super brackets '[', ']' to group and close brackets together.

## このプログラムについて。

Paul Graham 氏による記事 "The Roots of Lisp" の内容を実行できるものを目指した、純 LISP インタプリタです。

## コンパイル方法

gcc もしくは clang で Makefile を実行してください。

## 使用方法

終了するには、quit 関数を実行してください。
すなわち、

    % (quit)

と入力してください（% はプロンプト）。

「スーパー括弧」が使えます。これは、丸括弧の代わりに角括弧を使うと何重もの括弧のネストをまとめて閉じることができるものです。
左角括弧は右角括弧のこの機能をその深さで止めるために用いられます。
すなわち、((( ] や ([( ]) は ((( ))) と等しいです。

## イニシャル・ローディング機能

起動すると最初に init.txt を同じディレクトリ内から読み込みます。
ここに、あらかじめ読み込ませておきたい pure LISP プログラムを記述してください。
また、ないときは空の init.txt を作っておいてください。

## 注意事項

シンボルを評価すると、その値に自動的に置換されます。
よって、普通の LISP とは多少挙動の違う部分が表面的にはあります。
新しく用意されたシンボルには自分自身が値として含まれています。
それゆえ、

    % a
    a

となって、違いは表面的には現れませんが（% はプロンプト）、

    % (setq a b)
    a

のようにして値 b をシンボル a に設定すると、

    % a
    b

となります。


## 注意事項その２

ダイナミック・スコープです。

## 注意事項その３

ファイル名を指定しての読込・保存の機能は実装しておりません。

## 実装関数

### 基本７関数

- quote
- car
- cdr
- cons
- cond
- atom
- eq

LISP を齧ったことのある人なら、これらの意味はご存知でしょう。

### lambda

これも LISPer なら知っていて当然でしょう。当処理系においては、これはシンボルです。

### de

    (de func (x_1, ... x_n) S_1, ... S_n)

の形で用い、シンボル func を関数として定義します。
x_1, ... x_n は仮引数で、S_1, ... S_n
は S-式です。
S_1, ... S_n は順次評価され、最後の結果が関数の値として返されます。
内部的には、lamda 式のリストへと変換して、そのリストへのポインタを値としてシンボル func 内に格納します。

### setq

    (setq symbol value)

の形で用います。
シンボルに値を設定します。
当処理系においては、value としてラムダ式のリストを与えると、symbol が関数そのものになります。

### gc

ガベージ・コレクションを起動します。
ダミーとして () を返します。

## 予約シンボル

- ()
    + ヌルを意味します。正しくはシンボルではありません。内部構造もシンボルとは違っていて、名前を格納するセルも、値へのボインタを格納するセルも持ちません。当処理系においては、nil はヌルの意味で使えません（そうするよう、改造は容易）。
- t
    + 真偽値の真を意味します。
- lambda
    + 関数ではありません。先頭にあるとそのリスト全体が無名関数として扱われる、ただの印です。
- oblist
    + oblist を評価すると、すでに定義した関数や、値を設定したシンボルがリストになって表示されます。

## シンボルの構造

シンボル自体もセルから構成されています。すなわち、シンボルも当処理系においては一種のリストなのですが、ユーザからはリストとして扱えないようになっています。

    ((str_1 str_2 ... str_n) (value . next))

が、仮にリストとして表したときのシンボルです。

str_1 ... str_n はそれぞれ4文字までの文字列で、連結されてシンボル名として表示されます。
ただし、文字列バッファとして配列を用いて処理しているので、文字数に限界があります（とりあえずは 100 文字。もちろん変更可能）。
str_n の使用されない部分にはヌル文字が詰め込まれます。

value は関数ポインタ（本物のポインタ）へのポインタ（セル番号）や、リストおよびアトムへのポインタ（セル番号）を格納するためのセルです。

next は、デフォルトでは 0 すなわち () になっています。
けれども、シンボルを連結させて処理する過程において、次のシンボルへのポインタとして使われます。

## 既知の問題点

このコードはほとんどいじることなく PC-9801 のエミュレータにおいて、turbo C でコンバイルできるのですが、そのようにして試しに仮想 PC-9801 上で動かしたところ、当初の予想より遥かに容易にスタック・オーバーフローが起きることが判明しました。

作っている間は、C 言語のスタック（？）よりも、自前で用意したソフトウェア・スタックの方が先にオーバーフローするに違いない、と私は思い込んでいました。
ところが、古い時代の PC 環境だと、思ったよりもずっとたやすく本物のスタックがオーバーフローするようです。

この現象は、現代の PC においては、メモリが潤沢であるのと、スタックがオーバーフローしそうになるとスタック領域を自動で増やすなどの OS の仕組みとにより、回避されるようです。

それゆえ、私は「なぜ PC-98 だとセル の個数を 0x2000 より増やしたときバグるのだろう？」と、その原因が分からなかったのでした。
スタックがオーバーフローするなら、まず、自前で用意している貧弱な容量のスタックの方に起き、その旨のエラーが表示されるはず、と思い込んでいたので、その可能性を暗黙のうちに除外していました。

何のことはない、実はセルの数が原因ではなく、再帰呼び出しの深い処理をするたびにシステムのスタックがオーバーフローしていたのです。
これは、末尾呼び出し最適化を実装していないし、当然と言えば当然なのでした。
そして、もう一つのスタック、ソフト的な方のそれはガベージ・コレクションのためのものなのですが、その実装に関しても実は「手抜き」があります。

このソフト・スタックは、関数呼び出しの連鎖において使用中のセルを、処理系が一括して検出することができるようにするためだけに使われています。
つまり、ガベージ・コレクションが関わらない本来の処理のためにはローカル変数を用いているので、メモリの観点からすると重複しているのです。
その無駄を取り除けば、スタック・オーバーフローも緩和されるかもしれません。

けれども、ローカル変数の代わりに "stack[n]" などと書くのはプログラムを読みにくくします。
そもそも、この 'n' 自身がローカル変数である場合、これもスタックに積まれて再帰呼び出しを行うことになるのだから、意味がないことになります。

本当は末尾呼び出し最適化を実装すべきなのかもしれません。
けれども、初期の LISP 処理系にこれは実装されていたのでしょうか。
それは 純 LISP には大袈裟すぎる仕組みではないか。
そもそも、私はその実装の仕方がわかリませんし、それが必要だと初めからわかっていたら純 LISP インタプリタを作りたいと思っただろうか。
そして、私は「原理と実用の間には、やっぱり深い溝があるんだな、いつもこれだ」と、はや、憂いを感じます。

そういうわけで、この問題は放置することにします。現代の PC ではとりあえず動くからです。

## 言い訳めいたこと

第一に、シンボル名の格納場所をセル領域に含めてしまっています。これは、名前文字列に対して平均で二倍のメモリを消費することになるのですが、シンボル領域とセル領域とに分割管理するのが何か面倒なことのようにプログラミング時の私には思われた。また、純 LISP であることにかこつけて、数値を扱える仕組みを実装しておりません（尤も、改造するのは難しいことではないでしょう。ただ、私としては面倒なだけです）。

第二に、圧倒的にテストが足りていません。
特に、ガベージコレクションに関するテストがです。

第三に、あまり「引き締まった」アルゴリズムやコードではないかもしれません。それはひとえに、いかに楽にプログラミングするかを優先したからですし、私の元々の技量不足もあります。

そもそも、作者としては、ただ単にポール・グレアム氏のエッセイに載っている、いわゆる趙循環評価器の LISP コードを自前の処理系で動かしてみたかっただけなのだから、ご了承ください。
