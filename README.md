# pure LISP

## Abstruct

As the name suggests, this program is "pure LISP".

It supports super brackets '[', ']' to group and close brackets together.

## このプログラムについて。

Paul Graham 氏による記事 "The Roots of Lisp" の内容を実行できるものを目指した、純 LISP インタプリタです。

## コンパイル方法

gcc もしくは clang で Makefile を実行してください。

## 使用方法

終了するには、quit 関数を実行してください。
すなわち、

    % (quit)

と入力してください（% はプロンプト）。

「スーパー括弧」が使えます。これは、丸括弧の代わりに角括弧を使うと何重もの括弧のネストをまとめて閉じることができるものです。
左角括弧は右角括弧のこの機能をその深さで止めるために用いられます。
すなわち、((( ] や ([( ]) は ((( ))) と等しいです。

## イニシャル・ローディング機能

起動すると最初に init.txt を同じディレクトリ内から読み込みます。
ここに、あらかじめ読み込ませておきたい pure LISP プログラムを記述してください。
また、見当たらないときは空の init.txt を作っておいてください。

## 注意事項

シンボルを評価すると、その値に自動的に置換されます。
よって、普通の LISP とは多少挙動の違う部分が表面的にはあります。
新しく用意されたシンボルには自分自身が値として含まれています。
それゆえ、

    % a
    a

となって、違いは表面的には現れませんが（% はプロンプト）、

    % (setq a b)
    a

のようにして値 b をシンボル a に設定すると、

    % a
    b

となります。


## 注意事項その２

ダイナミック・スコープです。

## 注意事項その３

ファイル名を指定しての読込・保存の機能は実装しておりません。

## 実装関数

### 基本７関数

- quote
- car
- cdr
- cons
- cond
- atom
- eq

LISP を齧ったことのある人なら、これらの意味はご存知でしょう。
もちろん、(quote ...) の略記法として '... が使えます。

### eval

> (eval *form* *env*)

の形で用います。

*form* は S-式、すなわちシンボルなどのアトムから構成されるリストです。
当処理系では数アトムがありませんので、シンボルを並べてリストにしたものを入れ子にしたツリー構造のリスト、もしくは 単独のシンボル、ということになります。

*env* は環境リストです。
x1, x2, ... をシンボル、A1, A2, ... を任意の S-式として、

> ((x1 . A1) (x2 . A2) ...)

のような構造を持っている特定のリストです。
すなわち、car 部がシンボルを指しているドット対の成すリストです。
これは、シンボル x1, x2, ... がそれぞれ式 A1, A2, ... に置き換えられることを意味しています。
同じシンボルが含まれているときは、先頭に近いものが優先されます。

eval は *env* の示す置き換え規則の下、式 *form* を評価します。

この eval 関数は、いわばユーティリティ版であり、中身をなす実体の C 言語で書かれた関数は、インタプリタの中核になる仕組みです。
環境リストは、本来、インタプリタが行う関数呼び出しに応じて空リストの状態から自ずと生成されます。
したがって、ここでの環境リスト *env* はあくまでユーザが与えるものであって、インタプリタ内部で生成されている環境リストとは異なります。

他の注意点として、引数は前もって評価されるので、*env* として与えるリストなどは、先頭にクォート記号「'」をつける必要があります。

### lambda

これも LISPer なら知っていて当然でしょう。当処理系において、これはリストがラムダ式であることを示す単なる印としてのシンボルです。

### de

> (de *func* (x_1 ... x_n) s_1 ... s_n)

の形で用い、シンボル *func* を関数として定義します。
x_1, ..., x_n は仮引数で、s_1, ..., s_n
は S-式です。
s_1, ..., s_n は順次評価され、最後の結果が関数の値として返されます。
内部的には、lamda 式としてのリストへと変換して、そのリストへのポインタを値としてシンボル *func* 内に格納します。

de によって関数として定義されたシンボルは、oblist というリストに登録され、ガベージ・コレクションによって消去されなくなります。

### setq

> (setq var_1 val_1 var_2 val_2 ...)

の形で用います。
シンボルを変数として、それに値を代入します。
値はそれぞれの代入の直前に評価されます。
したがって、代入の順序によっては結果に違いが生じます。

環境リストにそのシンボルがあるときは、環境リストの値を書き換えます。

そうでないときは、シンボル内部に値を格納します。当処理系においては、このようなシンボルは oblist というリストに登録され、ガベージ・コレクションによって消去されなくなります。
（ただし、リストから削除する関数は作ってありません。
不便なのは何となくわかっているのですが、そうする必要に迫られるほど使っていないので。）

ちなみに当処理系においては、lambda 式をシンボルに代入すると（ただし、setq や psetq を使って代入するには式の前にクォート「'」を付ける必要があります）、そのシンボルが関数そのものになります。

### psetq

> (psetq var_1 val_1 var_2 val_2 ...)

の形で用います。
シンボルを変数として、それに値を代入します。
値はすべての代入に先立って一括して評価されます。
したがって、代入の順序による結果の違いは生じません。

あとの説明は setq と同じです。

### while

> (while *condition* s_1 ... s_n)

の形で用います。
これは、前置判定ループに相当するものです。
*condition* は何らかの S-式です。
*condition* を評価した結果が空リストにならない間、while は式 s_1, s_2, ... s_n を順次実行することを繰り返します。
最後の S_n が実行された結果が、全体の返す結果となります。

### until

> (until *condition* s_1 ... s_n)

の形で用います。
これは、**否定型**の後置判定ループに相当するものです。
*condition* は何らかの S-式です。
*condition* を評価した結果が空リスト**以外になる**まで、until は式 s_1, s_2, ... s_n を順次実行することを繰り返します。
最後の S_n が実行された結果が、全体の返す結果となります。

while と対にするなら肯定型の後置判定ループにすべきだと思いましたが、それだと do-while などと命名しなければなりません。
それゆえ、語呂の良さに引きずられたわけではないですが、until というわかりやすい名前をつけたかったためにあえてこうしました。

しかしながら、わかりやすい名前がつけやすい、ということは、人間の思考における自然発生的なメカニズムが知らず知らずのうちに働いているということかもしれません。
よって、とりあえずこのネーミングと定義の組み合わせを採用します。

### rplaca

> (rplaca *list* *form* )

の形で使います。
*list* はアトムであってはいけません。
*form* は任意の S-式です。
rplacd は、*list* の car を *form* で置き換えます。

    % (rplaca '(a b) (c d))
    ((c d) b)

この rplacd は、rplacd を実装する必要性が出てきたので、ならば rplaca もないとおかしい、ということで実装したものです。
使い方によっては循環リストが作れてしまうので、注意してください。

### rplacd

> (rplacd *list* *form* )

の形で使います。
*list* はアトムであってはいけません。
*form* は任意の S-式です。
rplacd は、*list* の cdr を *form* で置き換えます。

    % (rplacd '(a b) (c d))
    (b c d)

この rplacd は、ループ処理のできる趙循環評価器を作るときのために、いわば仕方なく実装したものです。
while のためには是非とも setq が必要で、setq のためには環境リストのドット対の cdr を書き換える必要があったからです。
使い方によっては循環リストが作れてしまうので、注意してください。

### gc

ガベージ・コレクションを起動します。
ダミーとして () を返します。

### quit

インタプリタを修了してコンソールに戻ります。

## 予約シンボル

- ()
  + 空リストを意味します。正しくはシンボルではありません。内部構造もシンボルとは違っていて、名前を格納するセルも、値へのボインタを格納するセルも持ちません。当処理系においては、nil という文字列は空リストの意味に使えません（そうするよう、改造は容易）。
- t
    + 真偽値の真を意味します。
- lambda
    + 関数ではありません。先頭にあるとそのリスト全体が無名関数として扱われる、ただの印です。
- oblist
    + oblist を評価すると、すでに定義した関数や、値を設定したシンボルがリストになって表示されます。

## シンボルの構造

シンボル自体もセルから構成されています。すなわち、シンボルも当処理系においては一種のリストなのですが、ユーザからはリストとして扱えないようになっています。

> ((str_1 str_2 ... str_n) (*value* . *next*))

が、仮にリストとして表したときのシンボルです。

str_1, ..., str_n はそれぞれ4文字までの文字列で、連結されてシンボル名として表示されます。
ただし、文字列バッファとして配列を用いて処理しているので、文字数に限界があります（とりあえずは 100 文字。もちろん変更可能）。
str_n の使用されない部分にはヌル文字が詰め込まれます。

*value* は関数ポインタ（本物のポインタ）へのポインタ（セル番号）や、リストおよびアトムへのポインタ（セル番号）を格納するためのセルです。

*next* は、デフォルトでは 0 すなわち () になっています。
けれども、インタプリタの内部処理においてポインタを連結させて扱う際に、次のシンボルへのポインタとして使われます。

## 既知の問題点

このコードはほとんどいじることなく PC-9801 のエミュレータにおいて、turbo C でコンバイルできるのですが、そのようにして試しに仮想 PC-9801 上で動かしたところ、当初の予想より遥かに容易にスタック・オーバーフローが起きることが判明しました。

作っている間は、C 言語のスタック（？）よりも、自前で用意したソフトウェア・スタックの方が先にオーバーフローするに違いない、と私は思い込んでいました。
ところが、古い時代の PC 環境だと、思ったよりもずっとたやすく本物のスタックがオーバーフローするようです。

この現象は、現代の PC においては、メモリが潤沢であるのと、スタックがオーバーフローしそうになるとスタック領域を自動で増やすなどの OS の仕組みとにより、回避されるようです。

それゆえ、私は「なぜ PC-98 だとセル の個数を 0x2000 より増やしたときバグるのだろう？」と、その原因が分からなかったのでした。
スタックがオーバーフローするなら、まず、自前で用意している貧弱な容量のスタックの方に起き、その旨のエラーが表示されるはず、と思い込んでいたので、その可能性を暗黙のうちに除外していました。

何のことはない、実はセルの数が原因ではなく、再帰呼び出しの深い処理をするたびにシステムのスタックがオーバーフローしていたのです。
これは、末尾呼び出し最適化を実装していないし、当然と言えば当然なのでした。
そして、もう一つのスタック、ソフト的な方のそれはガベージ・コレクションのためのものなのですが、その実装に関しても実は「手抜き」があります。

このソフト・スタックは、関数呼び出しの連鎖において使用中のセルを、処理系が一括して検出することができるようにするためだけに使われています。
つまり、ガベージ・コレクションが関わらない本来の処理のためにはローカル変数を用いているので、メモリの観点からすると重複しているのです。
その無駄を取り除けば、スタック・オーバーフローも緩和されるかもしれません。

けれども、ローカル変数の代わりに "stack[n]" などと書くのはプログラムを読みにくくします。
そもそも、この 'n' 自身がローカル変数である場合、これもスタックに積まれて再帰呼び出しを行うことになるのだから、意味がないことになります。

本当は末尾呼び出し最適化を実装すべきなのかもしれません。
けれども、初期の LISP 処理系にこれは実装されていたのでしょうか。
それは純 LISP には大袈裟すぎる仕組みではないか。
そもそも、私はその実装の仕方がわかリませんし、それが必要だと初めからわかっていたら純 LISP インタプリタを作りたいと思っただろうか。
そして、私は「原理と実用の間には、やっぱり深い溝があるんだな、いつもこれだ」と、はや、憂いを感じます。

そういうわけで、<s>この問題は放置することにします</s>。現代の PC ではとりあえず動くからです。

（せめてもの代替手段として、ループ処理をする関数を用意し、代入を行う関数を強化しました。
末尾再帰の代わりにループと代入を使え、ということです。
末尾呼び出し最適化を備えた処理系において、末尾再帰は実際のところループとして処理されているので、結局は似たようなものです。
……。しかしながら、これは少々考えさせられる事柄ですね。）

## 言い訳めいたこと

第一に、シンボル名の格納場所をセル領域に含めてしまっています。
これは、名前文字列に対して平均で二倍のメモリを消費することになるのですが、シンボル領域とセル領域とに分割管理するのが何か面倒なことのようにプログラミング時の私には思われた。
また、純 LISP であることにかこつけて、数値を扱える仕組みを実装しておりません（尤も、改造するのは難しいことではないでしょう。ただ、私としては面倒です）。

第二に、セルの情報を ID タグとして、セル一つにつき 1 バイト使って格納してあります。
これは実に無駄です。
セルは car 部と cdr 部の二つ一組で、それぞれが最低でも 2 バイトと考えれば、セルのアドレスはどれも 4 の倍数になります。
すると、アドレスの下位 2 ビットは意味がないことになり、そして、セルの二つの領域は他のセルのアドレスを格納するのですから、car 部、cdr 部とも下位 2 ビットを、すなわち一つのセルにつき計 4 ビットを空き領域として利用することが可能なのです。
最低でも 4 ビット使えるということです。
ここに、当処理系におけるセル ID の 4 種類、それに掛けることの使用・不使用の 2 状態、計 8 種類の情報を押し込めることは十分可能でした。
けれども、実際にその情報をセル・アドレスから取り出したり書き込んだりする仕組みのことを考えると、気が遠くなりました。
ルーチン自体は一度定義してしまえばあとは機械がやるので、問題になるのは実行速度のオーバーヘッドくらいです。
しかし、これだと、直に添字やポインタでセルを指定することができなくなります。間にアドレス処理のための関数呼び出しが一つ挟まるからです。
そして、セルの指定が単発で済むことは稀で、「友達の先輩の親戚」みたいに、入れ子状に組み合わさっている場合が多いので、これはバカにできないのです。
マクロではうまく処理できない場合があります。
もし、友達をあだ名で呼ぶ代わりにフルネームでいつも呼ばなければならないとしたら、そんなわずかな違いでも、実際は耐え難くなるでしょう。
それゆえ、この方法は採りませんでした。

つい長くなりました。以下、簡潔に述べます。

第三。圧倒的にテストが足りていません。
特に、ガベージコレクションに関するテストがです。

第四。あまり「引き締まった」アルゴリズムやコードではないかもしれません。それはひとえに、いかに楽にプログラミングするかを優先したからですし、私の元々の技量不足もあります。

そもそも、作者としては、ただ単にポール・グレアム氏のエッセイに載っている、いわゆる趙循環評価器の LISP コードを自前の処理系で動かしてみたかっただけなのだから、ご了承ください。
