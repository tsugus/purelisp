; (C) 2024-2025 Tsugu
; Version 0.2.0

; -------------------------------------
; Basic Functions

(de caar (x) (car (car x)))
(de cadr (x) (car (cdr x)))
(de cdar (x) (cdr (car x)))
(de cddr (x) (cdr (cdr x)))

(de caaar (x) (car (caar x)))
(de caadr (x) (car (cadr x)))
(de cadar (x) (car (cdar x)))
(de caddr (x) (car (cddr x)))

(de cdaar (x) (cdr (caar x)))
(de cdadr (x) (cdr (cadr x)))
(de cddar (x) (cdr (cdar x)))
(de cdddr (x) (cdr (cddr x)))

(de caddar (x) (car (cddar x)))

(de list x x)

(de null (x)
  (eq x '()))

(de and (x y)
  (cond (x (cond (y 't)
                 ('t '())))
        ('t '())))

(de not (x)
  (cond (x '())
        ('t 't)))

(de reverse (l) (
  (lambda (acc)
    (while l
      (setq acc (cons (car l) acc))
      (setq l (cdr l))
      acc))
  '()))

(de append (x y) (
  (lambda (x)
    (while (not (atom x))
      (setq y (cons (car x) y))
      (setq x (cdr x)))
    y)
  (reverse x)))

(de pair (x y) (
  (lambda (acc)
    (cond
      ((and (null x) (null y))
        '())
      ('t
        (while (and (not (atom x)) (not (atom y)))
          (setq acc (cons (cons (car x) (car y)) acc))
          (setq x (cdr x))
          (setq y (cdr y))
          acc))))
  '()))

(de assoc (x y)
  (while (and y (not (eq x (caar y))))
    (setq y (cdr y)))
  (cdar y))

; -------------------------------------
; A Metacircular Evaluator (, which is based on "The Roots of Lisp" by Paul Graham)

(de eval_ (e a)
  (cond
    ((atom e) (assoc e a))
    ((atom (car e))
    (cond
      ((eq (car e) 'quote) (cadr e))
      ((eq (car e) 'atom) (atom (eval_ (cadr e) a)))
      ((eq (car e) 'eq) (eq (eval_ (cadr e) a)
                            (eval_ (caddr e) a)))
      ((eq (car e) 'car) (car (eval_ (cadr e) a)))
      ((eq (car e) 'cdr) (cdr (eval_ (cadr e) a)))
      ((eq (car e) 'cons) (cons (eval_ (cadr e) a)
                                (eval_ (caddr e) a)))
      ((eq (car e) 'cond) (evcon (cdr e) a))
      ((eq (car e) 'setq) (envset (cadr e)
                                  (eval_ (caddr e) a) a))
      ((eq (car e) 'while) (while (eval_ (cadr e) a)
                                  (evals (cddr e) a)))
      ((eq (car e) 'rplaca) (rplaca (eval_ (cadr e) a)
                                    (eval_ (caddr e) a)))
      ((eq (car e) 'rplacd) (rplacd (eval_ (cadr e) a)
                                    (eval_ (caddr e) a)))
      ('t (eval_ (cons (assoc (car e) a) (cdr e)) a))))
    ((eq (caar e) 'label)
      (eval_ (cons (caddar e) (cdr e))
        (cons (cons (cadar e) (car e)) a)))
    ((eq (caar e) 'lambda)
      (evals (cddar e)
        (append (pair (cadar e) (evlis (cdr e) a)) a)))))

(de evcon (c a)
    (while (and c (not (eval_ (caar c) a)))
      (setq c (cdr c)))
    (evals (cdar c) a))

(de evlis (m a) (
  (lambda (m acc)
    (while m
      (setq acc (cons (eval_ (car m) a) acc))
      (setq m (cdr m)))
    acc)
  (reverse m) '()))

; Sequential evaluation of the elements of a list
(de evals (l env) (
  (lambda (rslt)
    (while l
      (setq rslt (eval_ (car l) env))
      (setq l (cdr l))
    rslt))
  '()))

; In an environment list, set y at x.
(de envset (x y env) (
  (lambda (l)
    (while (and l (not (eq x (caar l))))
      (setq l (cdr l)))
    (cond (l (rplacd (car l) y)))
    y)
  env))

; -------------------------------------
; Test of eval_

; = a
(eval_ 'x '((x.a) (y.b)))

; = t
(eval_ '(eq 'a 'a) '())

; = (a b c)
(eval_ '(cons x '(b c)) '((x.a) (y.b)))

; = list
(eval_ '(cond ((atom x) 'atom)
              ('t 'list))
'((x '(a b))))

; = (a b c)
(eval_ '(f '(b c))
'((f . (lambda (x) (cons 'a x)))))

; = a
(eval_ '(
  (label firstatom (lambda (x)
    (cond ((atom x) x)
          ('t (firstatom (car x))))))
  y)
'((y . ((a b) (c d)))))

; = (a c d)
(eval_ '(
  (lambda (x y) (cons x (cdr y)))
  'a
  '(b c d))
'())

; -------------------------------------
; Test 2

(eval_ '(
  (lambda (l) (
    (lambda (acc)
      (while l
        (setq acc (cons (car l) acc))
        (setq l (cdr l))
        acc))
    '()))
  '(1 2 3 4 5 6 7 8 9 10)
) '())

(eval_ '(
  (lambda (x y) (
    (lambda (x)
      (while (cond ((atom x) '())
                   ('t 't))
        (setq y (cons (car x) y))
        (setq x (cdr x)))
      y)
    (
      (lambda (l) (
        (lambda (acc)
          (while l
            (setq acc (cons (car l) acc))
            (setq l (cdr l))
            acc))
        '()))
      x)
    )
  )
  '(1 2 3 4 5 6 7 8 9) '(10)
) '())

; -------------------------------
